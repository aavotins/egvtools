% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/radius_function.r
\name{radius_function}
\alias{radius_function}
\title{Extract and Rasterize Summary Statistics from Buffered Radii Using exactextractr}
\usage{
radius_function(
  kvadrati_path,
  radii_path,
  tikls100_path,
  template_path,
  input_layers,
  layer_prefixes,
  output_dir = "./Extracted_Layers",
  unlink_tiles = TRUE,
  n_workers = 1,
  radii = c("r500", "r1250", "r3000", "r10000"),
  fill_missing = TRUE,
  radius_mode = "sparse",
  IDW_weight = 2,
  extract_fun = "mean",
  os_type = "auto",
  future_max_size = 8 * 1024^3,
  gdal_opts = c("COMPRESS=LZW", "TILED=YES", "BIGTIFF=IF_SAFER", "NUM_THREADS=ALL_CPUS",
    "BLOCKXSIZE=256", "BLOCKYSIZE=256"),
  write_datatype = NULL,
  NAflag = NULL,
  terra_memfrac = 0.7,
  terra_tempdir = tempdir(),
  terra_todisk = TRUE,
  quiet = FALSE
)
}
\arguments{
\item{kvadrati_path}{Path to directory containing 1 ha grid-cell GeoParquet tiles (e.g., \verb{.../lapas/}).}

\item{radii_path}{Path to directory with buffered polygon radii tiles (\code{r500}, \code{r1250}, \code{r3000}, \code{r10000}).}

\item{tikls100_path}{Path to GeoParquet for the 100 m grid (must contain \code{rinda300} and \code{ID1km}).}

\item{template_path}{Path to the template raster (final alignment target; e.g., \code{LV100m_10km.tif}).}

\item{input_layers}{Named character vector of covariate raster paths (values are file paths,
names are the \strong{layer prefixes} used in outputs).}

\item{layer_prefixes}{Character vector of names (same length/order as \code{input_layers}) to use as
output layer prefixes.}

\item{output_dir}{Output directory root. Default \code{"./Extracted_Layers"}.}

\item{unlink_tiles}{Logical; delete per-tile rasters after merging. Default \code{TRUE}.}

\item{n_workers}{Number of parallel workers. Default \code{1}.}

\item{radii}{Character vector of radii to process (subset of: \code{"r500"}, \code{"r1250"}, \code{"r3000"}, \code{"r10000"}).}

\item{fill_missing}{If \code{TRUE}, run Whitebox IDW gap filling on the projected mosaic.}

\item{radius_mode}{\code{"sparse"} or \code{"dense"}. Controls which buffered files are used:
\emph{\code{"sparse"}} uses \code{pts100} for r500/r1250, \code{pts300} for r3000, and \code{pts1000/pts1km} for r10000;
\emph{\code{"dense"}} uses only \code{pts100} for all radii.}

\item{IDW_weight}{Numeric power for Whitebox IDW. Default \code{2}.}

\item{extract_fun}{Function or single string (e.g., \code{"mean"}) passed to \code{exactextractr::exact_extract()}
that returns \strong{one scalar per polygon}. If it returns multiple values per polygon, the function stops.}

\item{os_type}{\code{"auto"}, \code{"windows"}, \code{"mac"}, \code{"linux"}, or \code{"slurm"}. Parallel backend selector.}

\item{future_max_size}{Max globals per worker (bytes). Default \code{8 * 1024^3}.}

\item{gdal_opts}{GDAL creation options for writes. Default
\code{c("COMPRESS=LZW","TILED=YES","BIGTIFF=IF_SAFER","NUM_THREADS=ALL_CPUS","BLOCKXSIZE=256","BLOCKYSIZE=256")}.}

\item{write_datatype}{Optional terra datatype (e.g., \code{"FLT4S"}, \code{"INT2S"}). Default \code{NULL} (terra default).}

\item{NAflag}{Optional NA flag for writing. Default \code{NULL} (terra default).}

\item{terra_memfrac}{\code{terraOptions(memfrac=...)}. Default \code{0.7}.}

\item{terra_tempdir}{Temp dir for heavy ops. Default \code{tempdir()}.}

\item{terra_todisk}{If \code{TRUE}, prefer on-disk operations. Default \code{TRUE}.}

\item{quiet}{Suppress progress prints. Default \code{FALSE}.}
}
\value{
Invisibly, a data.frame with columns:
\verb{layer, radius, output_path, n_tiles_merged, gaps_before, gaps_after, filter_size_used, gap_filled}.
}
\description{
Extracts summary statistics from raster layers using buffered polygon zones of multiple radii
and rasterizes them onto a common template grid. Supports parallel execution on SLURM clusters,
Windows, macOS, and Linux.
}
\details{
\strong{Workflow}
\enumerate{
\item Discover inputs (1 ha tiles and buffered radii files) according to \code{radius_mode}.
\item \strong{Per tile (parallel):} read tile zones and available radii; crop to bbox + 1 km;
\strong{run \code{exactextractr::exact_extract()} once per radius} over the (cropped) raster stack,
producing one value per polygon per layer; join to the appropriate 100 m grid (or its
parent for r3000/r10000), and rasterize to the cropped template via \code{fasterize},
writing \strong{per-tile GeoTIFFs}.
\item For each \verb{layer at radius}: VRT-merge tiles then \strong{project to the full template grid}
then mask to the template footprint.
\item \strong{Gap analysis & optional fill:} count NA gaps inside the template. If \code{fill_missing = TRUE}
and gaps exist, estimate max gap width on the template (\code{terra::distance()} on a fillable
mask), set Whitebox \code{filter = 2 * ceil(max_gap / pixel_size)} with \strong{min clamp = 3},
run \code{whitebox::wbt_fill_missing_data()}, then mask again.
\item \strong{CRS guard & write:} set \code{terra::crs(out) <- terra::crs(template, proj = FALSE)} and
write with LZW tiling via \strong{atomic writes}.
\item \strong{Return:} a data.frame with
\verb{layer, radius, output_path, n_tiles_merged, gaps_before, gaps_after, filter_size_used, gap_filled}.
}

\strong{Output parsing guard}
Handles single vectors, data.frames (\code{"mean.Layer"} or layer names), and lists
(one element per feature: numeric vectors or 1-row data.frames). Clear error otherwise.

\strong{Per-worker cache}
Large \code{sf} objects like a ~6.5M-feature \code{tikls100} are \strong{loaded once per worker}
to avoid repeated I/O and pointer invalidation issues in parallel sessions.

\strong{CRS guard}
Outputs copy the CRS string from the template using
\code{terra::crs(template, proj = FALSE)} to keep a Proj.4-style string for maximal compatibility.
}
\examples{
\dontrun{
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/lapas/",
  radii_path     = "./Templates/TemplateGridPoints/lapas/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c(Soils_txtSand  = "./Rastri_100m/RAW/Soils_txtSand_cell.tif",
                     Soils_txtSilt  = "./Rastri_100m/RAW/Soils_txtSilt_cell.tif",
                     Soils_txtClay  = "./Rastri_100m/RAW/Soils_txtClay_cell.tif"),
  layer_prefixes = c("Soils_txtSand","Soils_txtSilt","Soils_txtClay"),
  output_dir     = "./Extracted_Layers",
  n_workers      = 4,
  radii          = c("r500","r1250","r3000","r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2
)
}

}
