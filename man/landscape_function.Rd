% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/landscape_function.R
\name{landscape_function}
\alias{landscape_function}
\title{Compute landscape-level metrics per zone (tiled), merge, analyze gaps, optionally fill with IDW, and write rasters}
\usage{
landscape_function(
  landscape,
  zones = "./Templates/TemplateGrids/tikls500_sauzeme.parquet",
  id_field = "rinda500",
  tile_field = "tks50km",
  template = "./Templates/TemplateRasters/LV500m_10km.tif",
  out_dir,
  out_filename,
  out_layername,
  what = "lsm_l_shdi",
  lm_args = NULL,
  buffer_m = 1000,
  rasterize_engine = c("fasterize", "terra"),
  n_workers = 1,
  future_max_size = 4 * 1024^3,
  gdal_opts = c("COMPRESS=LZW", "TILED=YES", "BIGTIFF=IF_SAFER"),
  write_datatype = NULL,
  NAflag = NA_real_,
  keep_tiles = FALSE,
  skip_existing = TRUE,
  terra_memfrac = 0.7,
  terra_tempdir = tempdir(),
  terra_todisk = TRUE,
  force_gc = FALSE,
  quiet = FALSE,
  report_gaps = TRUE,
  report_gap_size = TRUE,
  fill_gaps = FALSE,
  idw_weight = 2,
  filter_size_cells = "auto",
  plot_result = FALSE,
  plot_gaps = FALSE
)
}
\arguments{
\item{landscape}{SpatRaster or path(s) to .tif (class labels). Multi-layer supported.}

\item{zones}{sf polygons or path to \pkg{sfarrow} GeoParquet. Default \code{"./Templates/TemplateGrids/tikls500_sauzeme.parquet"}.}

\item{id_field}{Zone id field (default \code{"rinda500"}).}

\item{tile_field}{Tiling field (default \code{"tks50km"}).}

\item{template}{SpatRaster or path defining target grid/CRS/cellsize. Default \code{"./Templates/TemplateRasters/LV500m_10km.tif"}.}

\item{out_dir}{Output directory (created if missing).}

\item{out_filename}{Character vector: final filename(s) (no dir); one per input layer, matching order.}

\item{out_layername}{Character vector: final layer name(s); one per input layer, matching order.}

\item{what}{Landscapemetrics metric (default \code{"lsm_l_shdi"}).}

\item{lm_args}{Named list of extra args for \code{\link[landscapemetrics:sample_lsm]{landscapemetrics::sample_lsm()}} compatible with \code{what}.}

\item{buffer_m}{Numeric buffer (m) for tile bbox before crop (default \code{1000}).}

\item{rasterize_engine}{\code{"fasterize"} (default) or \code{"terra"}.}

\item{n_workers}{Integer; \code{1} = sequential.}

\item{future_max_size}{Max globals per worker (bytes); default \code{4 * 1024^3} (~4 GiB).}

\item{gdal_opts}{GDAL creation options (merged with tuned defaults:
\code{c("COMPRESS=LZW","TILED=YES","BIGTIFF=IF_SAFER","NUM_THREADS=ALL_CPUS","BLOCKXSIZE=256","BLOCKYSIZE=256")}).}

\item{write_datatype}{terra datatype string; if \code{NULL}, defaults to \code{"FLT4S"}.}

\item{NAflag}{Numeric NA value to write; if \code{NA}/\code{NULL}, a sensible default is chosen
(\code{FLT* to -9999}, \verb{INT2S to -32768}, \verb{INT4S to -2147483648}).}

\item{keep_tiles}{Logical; keep temp tiles dir (debug). Default \code{FALSE}.}

\item{skip_existing}{Logical; skip tiles/finals that already exist. Default \code{TRUE}.}

\item{terra_memfrac}{\code{terraOptions(memfrac=...)}. Default \code{0.7}.}

\item{terra_tempdir}{Temp dir for terra ops. Default \code{tempdir()}.}

\item{terra_todisk}{Logical or \code{NA}. If \code{TRUE}, prefer on-disk. Default \code{TRUE}.}

\item{force_gc}{Logical; call \code{gc()} at key checkpoints. Default \code{FALSE}.}

\item{quiet}{Suppress progress prints (\code{cat()})? Default \code{FALSE}.}

\item{report_gaps}{Logical; print/compute \code{gap_count}. Default \code{TRUE}.}

\item{report_gap_size}{Logical; compute/print maximum gap width (expensive). Default \code{TRUE}.}

\item{fill_gaps}{Logical; run Whitebox IDW fill if gaps exist. Default \code{FALSE}.}

\item{idw_weight}{Numeric; IDW power for Whitebox fill. Default \code{2}.}

\item{filter_size_cells}{Integer or \code{"auto"}; Whitebox window size (cells). Default \code{"auto"}.}

\item{plot_result}{Logical; plot final per-layer raster(s). Default \code{FALSE}.}

\item{plot_gaps}{Logical; plot gap map(s) (1 = NA inside template). Default \code{FALSE}.}
}
\value{
A \strong{data.frame} (one row per layer) with:
\itemize{
\item \code{layer_name}, \code{output_path},
\item \code{tiles_written}, \code{tiles_skipped_existing}, \code{tiles_skipped_empty_crop}, \code{tiles_skipped_empty_join},
\item \code{merge_skipped}, \code{gap_count}, \code{max_gap_distance}, \code{filter_size_cells_used}, \code{gap_filled},
\item \code{n_tiles}, \code{n_zones}, \code{n_layers}, \code{elapsed_sec}.
Attributes: \code{"tile_dir"} (path or \code{NULL}), \code{"run_params"} (list).
}
}
\description{
Computes a \pkg{landscapemetrics} metric (default \code{"lsm_l_shdi"}), optionally with
extra \code{lm_args}, that yields one value per zone and \strong{per input layer}. Runs tile-by-tile
(by \code{tile_field}), writes per-tile rasters, merges to final per-layer GeoTIFF(s),
then performs \strong{gap analysis} (NA count within the template footprint and optional
maximum gap width) and \strong{optional IDW gap filling} via WhiteboxTools.
Returns a compact \strong{data.frame} with per-layer stats and timing.
}
\details{
\strong{Workflow}
\enumerate{
\item \strong{Inputs & CRS}
\itemize{
\item Accept paths or in-memory (\code{SpatRaster}, \code{sf}). Zones and landscape are aligned to the \strong{template} CRS/grid.
}
\item \strong{Tiling}
\itemize{
\item Split \code{zones} by \code{tile_field}; process each tile independently.
}
\item \strong{Per-tile (all layers)}
\itemize{
\item Quick extent crop (buffered by \code{buffer_m}), \code{landscapemetrics::sample_lsm()} per layer,
join back by \code{id_field}, rasterize (engine: \code{"fasterize"} or \code{"terra"}), mask to template crop,
and write tile raster. Skips empty crops/joins cleanly.
}
\item \strong{Merge per layer}
\itemize{
\item VRT over all tile rasters to final GeoTIFF with tuned GDAL options (LZW, tiling, BIGTIFF=IF_SAFER, threads).
\item CRS is \strong{forced to the template WKT} so \code{crs(output) == crs(template)} string-matches.
}
\item \strong{Gap analysis & optional fill (per layer)}
\itemize{
\item \code{gap_count}: number of NA cells \strong{inside} the template footprint.
\item If \code{report_gap_size=TRUE} or \code{filter_size_cells="auto"}, compute \strong{max gap width} (distance to nearest non-NA).
\item If \code{fill_gaps=TRUE} and gaps exist, fill with \code{whitebox::wbt_fill_missing_data()} using
\code{idw_weight} and \code{filter_size_cells} (or auto from the max gap width; odd, >=3).
\item Plot result and/or gaps if requested (side-by-side if both).
}
\item \strong{Return}
\itemize{
\item One row per output layer with paths, tile counters, gap stats, fill parameters, and elapsed seconds.
}
}
}
\examples{
\dontrun{
res_tbl <- landscape_function(
  landscape      = "./Rastri_10m/Ainava_KopejaiDaudzveidibai.tif",
  zones          = "./Templates/TemplateGrids/tikls500_sauzeme.parquet",
  id_field       = "rinda500",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV500m_10km.tif",
  out_dir        = "./out/lsm/",
  out_filename   = "Landscape_diversity.tif",
  out_layername  = "Landscape_diversity",
  what           = "lsm_l_shdi",
  rasterize_engine = "fasterize",
  n_workers      = 8,
  fill_gaps      = TRUE,
  plot_gaps      = TRUE,
  plot_result    = TRUE
)
print(res_tbl)

#' ## --- Total edge length per zone (ignore outside map boundary) ---
## Using a binary "water vs other" landscape, compute lsm_l_te per 500 m zone.
rez_edges <- landscape_function(
  landscape        = "./Rastri_10m/Ainava_vienk_mask.tif",
  zones            = "./Templates/TemplateGrids/tikls500_sauzeme.parquet",
  id_field         = "rinda500",
  tile_field       = "tks50km",
  template         = "./Templates/TemplateRasters/LV500m_10km.tif",
  out_dir          = "./",
  out_filename     = "edges_water.tif",
  out_layername    = "edges_water",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "terra",
  n_workers        = 8,
  future_max_size  = 2 * 1024^3,
  report_gaps      = TRUE,
  plot_result      = TRUE,
  plot_gaps        = TRUE
)
rez_edges
}

}
\seealso{
landscapemetrics::sample_lsm, terra::writeRaster, fasterize::fasterize, whitebox::wbt_fill_missing_data
}
