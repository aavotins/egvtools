% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/polygon2input.R
\name{polygon2input}
\alias{polygon2input}
\title{Rasterize polygons to a template grid, optionally restrict & cover gaps, then write GeoTIFF}
\usage{
polygon2input(
  vector_data,
  template_path,
  out_path = "./",
  file_name,
  value_field = NULL,
  constant_value = 1,
  fun = "max",
  value_type = c("categorical", "continuous"),
  project_mode = c("auto", "never", "always"),
  prepare = TRUE,
  restrict_to = NULL,
  restrict_values = NULL,
  background_raster = NULL,
  background_value = NULL,
  check_na = TRUE,
  plot_result = FALSE,
  plot_gaps = FALSE,
  NAflag = NULL,
  gdal_opts = c("COMPRESS=LZW", "TILED=YES", "BIGTIFF=IF_SAFER", "NUM_THREADS=ALL_CPUS",
    "BLOCKXSIZE=256", "BLOCKYSIZE=256"),
  write_datatype = NULL,
  terra_memfrac = 0.7,
  terra_tempdir = tempdir(),
  terra_todisk = FALSE,
  force_gc = FALSE,
  overwrite = FALSE,
  quiet = FALSE
)
}
\arguments{
\item{vector_data}{sf polygons/multipolygons to rasterize.}

\item{template_path}{Path to the template raster (.tif).}

\item{out_path}{Output directory. Default \code{"./"}.}

\item{file_name}{Output filename, e.g., \code{"my_input.tif"}.}

\item{value_field}{Character or \code{NULL}. Attribute to burn; if \code{NULL}, uses \code{constant_value}.}

\item{constant_value}{Numeric scalar burned when \code{value_field=NULL}. Default \code{1}.}

\item{fun}{Aggregation in \code{fasterize} for overlaps: one of \code{"max"}, \code{"sum"}, \code{"first"}, \code{"last"}, \code{"min"}, \code{"count"}.
Default \code{"max"}.}

\item{value_type}{Guides resampling \strong{if projection happens}:
\code{"categorical"} → method \code{"near"}, \code{"continuous"} → \code{"bilinear"}. Default \code{"categorical"}.}

\item{project_mode}{\code{"auto"} (default; project only if misaligned), \code{"never"}, or \code{"always"}.}

\item{prepare}{Logical. If \code{TRUE}, run \code{st_make_valid()} and transform to template CRS. Default \code{TRUE}.}

\item{restrict_to}{Optional raster mask (path or \code{terra} \code{SpatRaster}).}

\item{restrict_values}{Optional values to keep from \code{restrict_to}: numbers (scalar/vector) and/or
\strong{range strings} using bracket inclusivity, e.g. \code{"(0,5]"}, \code{"[10,)"}, \code{"(-inf,0)"}. Multiple entries are OR’ed.
If \code{NULL}, keep non-NA cells of \code{restrict_to}.}

\item{background_raster}{Optional path/\code{SpatRaster} used to cover remaining NAs.}

\item{background_value}{Numeric constant to fill where result is NA \strong{if} no \code{background_raster}.
Default \code{NULL} (no covering).}

\item{check_na}{Logical. If \code{TRUE}, report NA counts before/after. Default \code{TRUE}.}

\item{plot_result}{Logical. Plot final raster (after all processing). Default \code{FALSE}.}

\item{plot_gaps}{Logical. Plot NA gaps (only within template footprint). If both plot flags are \code{TRUE},
plots are side-by-side. Default \code{FALSE}.}

\item{NAflag}{Optional NA flag for writing (passed to GDAL). Default \code{NULL} (auto if needed).}

\item{gdal_opts}{Character vector of GDAL creation options (merged with tuned defaults).
Default \code{c("COMPRESS=LZW","TILED=YES","BIGTIFF=IF_SAFER","NUM_THREADS=ALL_CPUS","BLOCKXSIZE=256","BLOCKYSIZE=256")}.}

\item{write_datatype}{Optional terra datatype for writing (e.g., \code{"FLT4S"}, \code{"INT2S"}). Default \code{NULL} (auto).}

\item{terra_memfrac}{\code{terraOptions(memfrac=...)}. Default \code{0.7}.}

\item{terra_tempdir}{Temp dir for terra operations. Default \code{tempdir()}.}

\item{terra_todisk}{Logical or \code{NA}. If \code{TRUE}, prefer on-disk processing for heavy ops (project/mask/cover).
If \code{FALSE}, prefer memory. If \code{NA}, leave session default unchanged. Default \code{FALSE}.}

\item{force_gc}{Logical; call \code{gc()} at checkpoints. Default \code{FALSE}.}

\item{overwrite}{Overwrite output? Default \code{FALSE}.}

\item{quiet}{Suppress progress prints (\code{cat()})? Default \code{FALSE}.}
}
\value{
Invisibly, a list with \code{out_file}, \code{n_cells}, \code{n_na_initial}, \code{n_na_final}, \code{elapsed_sec}, and \code{crs}.
}
\description{
Rasterizes polygon/multipolygon \strong{sf} data to a raster aligned to a \strong{template} GeoTIFF.
Rasterization targets a \code{raster::RasterLayer} built from the template (so grids normally match).
Projection is optional (\code{project_mode}). Missing values are counted \strong{only} over valid template
cells. You may optionally restrict the result with a raster mask (\code{restrict_to}) using numeric
values or \strong{bracketed range strings} (e.g., \code{"(0,5]"}, \code{"[10,)"}). Remaining \code{NA} cells can be
filled by covering with a background raster (\code{background_raster}) or a constant (\code{background_value}).
For large rasters, heavy steps (projection/mask/cover) can stream to disk via \code{terra_todisk=TRUE}.
}
\details{
\strong{Workflow}
\enumerate{
\item (Optional) \code{prepare=TRUE} ensures valid polygons and transforms to the template CRS
(\code{sf::st_make_valid()} + \code{sf::st_transform()}). Set \code{prepare=FALSE} if you guarantee this.
\item Rasterize with \code{fasterize::fasterize()} onto a \code{raster::RasterLayer} built from the template.
\item Depending on \code{project_mode}, \strong{project} to the template grid:
\itemize{
\item \code{"auto"} (default): checks CRS/resolution/extent/rows/cols; projects \strong{only if needed}.
\item \code{"never"}: skips projection.
\item \code{"always"}: forces projection (\code{"near"} for \code{value_type="categorical"}, \code{"bilinear"} for \code{"continuous"}).
}
\item Apply a \strong{template mask} (keeps template extent and \code{NA} footprint).
\item (Optional) \strong{Restrict} by \code{restrict_to} (path or in-memory \code{SpatRaster}):
\itemize{
\item If \code{restrict_values} is \code{NULL}, keep \strong{non-NA} cells of \code{restrict_to}.
\item If supplied, keep cells matching \strong{numbers} (scalar/vector) and/or \strong{ranges} using bracket
syntax: \code{"(a,b)"} open; \code{"[a,b]"} closed; mix ends like \code{"(a,b]"}. Use \code{-inf}/\code{+inf} for unbounded,
e.g., \code{"[10,)"}, \code{"(-inf,0)"}. Multiple entries are OR’ed.
}
\item (Optional) \strong{Cover} remaining \code{NA} cells:
\itemize{
\item with \code{background_raster} (aligned to template; projected if needed), or
\item with a \strong{constant} using \code{background_value} (fast and memory-light).
}
\item A \strong{final mask} to the template is applied \strong{before plotting and saving}.
\item NA counts are computed with \code{terra::global()} on raster masks (memory-safe).
}

\strong{Datatype & NAflag auto-chooser}
If you do \strong{not} provide \code{write_datatype}/\code{NAflag}, the function picks:
\itemize{
\item \code{value_type="categorical"} → \code{write_datatype="INT2S"}, \code{NAflag=-32768}
\item \code{value_type="continuous"} → \code{write_datatype="FLT4S"}, \code{NAflag} omitted
You can always override via arguments.
}

\strong{Performance & stability}
\itemize{
\item For very large rasters (e.g., ~1.3B cells), set \code{terra_todisk=TRUE} and consider a fast SSD for
\code{terra_tempdir}. This streams big operations to disk and avoids “vector memory limit” errors.
\item Projection is often unnecessary here because rasterization targets the template’s grid; \code{"auto"}
will detect alignment and skip it.
\item Writes are \strong{atomic}: a temporary file is written and then moved into place.
}
}
\section{Range string syntax for restrict_values}{

Use "(a,b)" for open interval, "\link{a,b}" for closed; mix ends like "(a,b]". Use -inf/+inf (or inf)
for unbounded, e.g., "[10,)", "(-inf,0)". Supply multiple strings to OR them, e.g., c("(0,5]","[10,15)").

[10,)", "(-inf,0)". Supply multiple strings to OR them, e.g., c("(0,5]: R:10,)\%22,\%20\%22(-inf,0)\%22.\%20Supply\%20multiple\%20strings\%20to\%20OR\%20them,\%20e.g.,\%20c(\%22(0,5
}

\examples{
\dontrun{ 
# Basic: burn constant "1", continuous output, no covering 
polygon2input( 
vector_data = my_polys_sf,
template_path = "./Templates/TemplateRasters/template10m.tif", 
out_path = "./Outputs", 
file_name = "mask_const1.tif", 
value_field = NULL, 
constant_value = 1, 
value_type = "continuous", 
project_mode = "auto", 
prepare = FALSE, 
check_na = TRUE, 
plot_result = TRUE, 
overwrite = TRUE #' ) 

# Restrict to classes 1 and 2, plus (10,20], then fill remaining NAs with 0 
polygon2input( 
vector_data = my_polys_sf, 
template_path = "./Templates/TemplateRasters/template10m.tif", 
out_path = "./Outputs", 
file_name = "mask_restricted_bg0.tif", 
value_field = "attr", 
value_type = "categorical", 
restrict_to = "./mask_classes.tif", 
restrict_values = c(1, 2, "(10,20]"), 
background_value = 0, 
terra_todisk = TRUE, # stream big ops to disk 
terra_tempdir = tempdir(), # or a fast SSD scratch 
check_na = TRUE, 
plot_result = TRUE, 
plot_gaps = TRUE, 
overwrite = TRUE 
) 
}

}
\seealso{
\code{\link[=tiled_buffers]{tiled_buffers()}}, \code{\link[=tile_vector_grid]{tile_vector_grid()}}
}
