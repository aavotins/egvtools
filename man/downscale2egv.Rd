% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/downscale2egv.R
\name{downscale2egv}
\alias{downscale2egv}
\title{Downscale & Align a Raster to a Template, with optional gap fill & IDW smoothing}
\usage{
downscale2egv(
  template_path,
  grid_path,
  rawfile_path,
  out_path,
  file_name,
  layer_name,
  interpolation_method = "auto",
  buffer_m = 10000,
  check_na = FALSE,
  fill_gaps = TRUE,
  idw_weight = 2,
  filter_size_cells = "auto",
  plot_gaps = FALSE,
  plot_result = FALSE,
  smooth = FALSE,
  smooth_radius_km = 10,
  smooth_agg_factor = 10,
  smooth_power = 0.5,
  smooth_epsilon = 0,
  smooth_nmax = 50,
  smooth_force = FALSE,
  gdal_opts = c("COMPRESS=LZW", "TILED=YES", "BIGTIFF=IF_SAFER"),
  write_datatype = NULL,
  NAflag = NULL,
  terra_memfrac = 0.7,
  terra_tempdir = tempdir(),
  terra_todisk = TRUE,
  force_gc = FALSE,
  return_visible = FALSE,
  quiet = FALSE
)
}
\arguments{
\item{template_path}{Character path to a template GeoTIFF \strong{or} a \code{terra::SpatRaster}.}

\item{grid_path}{Character path to a GeoParquet grid \strong{or} an \code{sf} object (used only for bbox).}

\item{rawfile_path}{Character path to the input raster \strong{or} a \code{SpatRaster}.}

\item{out_path}{Character. Directory for the output GeoTIFF (created if missing).}

\item{file_name}{Character. Output file name (e.g., \code{"result.tif"}).}

\item{layer_name}{Character. Band name to set on the output.}

\item{interpolation_method}{\code{"auto"} (default), or \code{"bilinear"}, \code{"near"}, \code{"cubicspline"}, \code{"cubic"}.}

\item{buffer_m}{Numeric. Buffer distance (meters) applied to the grid bbox before cropping. Default \code{10000}.}

\item{check_na}{Logical. If \code{TRUE}, report NA gap count (inside template). Default \code{FALSE}.}

\item{fill_gaps}{Logical. If \code{TRUE}, fill NA gaps via Whitebox. Default \code{TRUE}.}

\item{idw_weight}{Numeric. IDW power used by Whitebox gap filling. Default \code{2}.}

\item{filter_size_cells}{Integer or \code{"auto"}. Window size (in \strong{cells}) for gap filling. Default \code{"auto"}.}

\item{plot_gaps, plot_result}{Logical flags for diagnostics/plots (side-by-side if both).}

\item{smooth}{Logical. Enable \strong{IDW} smoothing. Default \code{FALSE}.}

\item{smooth_radius_km}{Numeric. IDW smoothing radius (km). Default \code{10}.}

\item{smooth_agg_factor}{Integer. Aggregate factor before point creation. Default \code{10}.}

\item{smooth_power}{Numeric. IDW power. Default \code{0.5}.}

\item{smooth_epsilon}{Numeric. Small smoothing term (if supported by your \code{terra}). Default \code{0}.}

\item{smooth_nmax}{Integer. Max neighbors (if supported by your \code{terra}). Default \code{50}.}

\item{smooth_force}{Logical. Allow smoothing for integer/factor rasters (not recommended). Default \code{FALSE}.}

\item{gdal_opts}{Character vector. GDAL creation options; merged with tuned defaults:
\code{c("COMPRESS=LZW","TILED=YES","BIGTIFF=IF_SAFER","NUM_THREADS=ALL_CPUS","BLOCKXSIZE=256","BLOCKYSIZE=256")}.}

\item{write_datatype}{Character or \code{NULL}. Optional terra datatype (e.g., \code{"FLT4S"}).}

\item{NAflag}{Numeric/integer NoData value to write; \code{NULL} to omit (default).}

\item{terra_memfrac}{\code{terraOptions(memfrac=...)}. Default \code{0.7}.}

\item{terra_tempdir}{Temp dir for terra operations. Default \code{tempdir()}.}

\item{terra_todisk}{Logical or \code{NA}. If \code{TRUE}, prefer on-disk processing for heavy ops. Default \code{TRUE}.}

\item{force_gc}{Logical; call \code{gc()} at checkpoints. Default \code{FALSE}.}

\item{return_visible}{Logical. If \code{TRUE}, return the summary visibly; otherwise invisibly. Default \code{FALSE}.}

\item{quiet}{Suppress progress prints (\code{cat()})? Default \code{FALSE}.}
}
\value{
A \strong{data.frame} with columns:
\code{output}, \code{gap_count}, \code{max_gap_distance}, \code{filter_size_cells}, \code{smoothed},
\code{smoothing_radius_used}, \code{elapsed_sec}.
}
\description{
Aligns a source raster to a template grid (CRS, resolution, extent), masks to the
template footprint, and optionally:
(1) fills NoData gaps using WhiteboxTools' IDW-based \code{fill_missing_data}, and
(2) applies \strong{IDW smoothing} to reduce blockiness from low-resolution inputs.

\strong{Mass preservation:} IDW smoothing (and most simple smoothers) are \strong{not mass-preserving}.
If conservation of totals/means matters (globally or by zones), post-smoothing rescaling
is recommended (see \emph{Details}).

If \code{interpolation_method = "auto"}, integer/factor inputs use \code{"near"};
continuous inputs use \code{"bilinear"}.
}
\details{
\strong{Workflow}
\enumerate{
\item \strong{Inputs}: accepts paths or in-memory objects (\code{SpatRaster} / \code{sf}).
\item \strong{Fast crop}: transforms the grid bbox to the template CRS, expands by \code{buffer_m},
crops the raw raster early to minimise work.
\item \strong{Method auto-choice}: \code{"near"} for integer/factor rasters, otherwise \code{"bilinear"}.
\item \strong{Align}: \code{terra::project(raw_crop, template, method)} then \code{terra::mask(..., template)}.
\item \strong{Gaps}: optional internal NA counts on the template footprint only.
\item \strong{Gap fill (optional)}: Whitebox \code{wbt_fill_missing_data}, with window auto-sized from
the widest gap (or user \code{filter_size_cells}).
\item \strong{Smoothing (optional)}: IDW via \code{terra::interpIDW()} on points derived from an
aggregated version of the filled raster; masked back to template.
\item \strong{Plotting}: \code{plot_gaps}, \code{plot_result} (side-by-side if both).
\item \strong{Write}: atomic write (tmp + rename), LZW, tiling, \code{BIGTIFF=IF_SAFER}, threaded;
output CRS \strong{forced to template WKT/EPSG} so \code{crs(out) == crs(template)} is TRUE.
\item \strong{Sink safety & memory}: snapshots/restore sinks (prevents stuck console if interrupted);
\code{terraOptions(memfrac/tempdir/todisk)} set then restored; optional \code{gc()}.
}

\strong{IDW smoothing}
Aggregate to points to IDW back to template. Controls:
\itemize{
\item \code{smooth_radius_km} search radius (km; converted to template units),
\item \code{smooth_agg_factor} aggregation factor before point creation,
\item \code{smooth_power}, \code{smooth_epsilon}, \code{smooth_nmax}.
Set \code{smooth_force=TRUE} to allow smoothing of integer/factor rasters (not recommended).
}

\strong{Mass preservation tips}
The smoothed result will generally \emph{not} preserve totals/means.
\itemize{
\item \strong{Global}: scale smoothed raster to match global sum.
\item \strong{Zonal}: compute per-zone factors on the original coarse grid and multiply.
}
}
\examples{
\dontrun{
out_dir <- tempdir()
df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/grid_10km.parquet",
  rawfile_path  = "./MyCoarse/coarse_indicator.tif",
  out_path      = out_dir,
  file_name     = "indicator_egv.tif",
  layer_name    = "indicator",
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 10,
  plot_result   = TRUE
)
print(df)
}

}
\seealso{
terra::project(), terra::mask(), terra::interpIDW(),
whitebox::wbt_fill_missing_data(), sfarrow::st_read_parquet()
}
